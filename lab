#1. Historgram

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Step 1: Read grayscale image
img = cv2.imread("beach.jpeg", cv2.IMREAD_GRAYSCALE)

# Get image shape
rows, cols = img.shape
L = 256  # Number of gray levels

# Step 2: Compute histogram
hist = np.zeros(L, dtype=int)
for r in img.flatten():
    hist[r] += 1

# Step 3: Normalize to get probability distribution
pr = hist / (rows * cols)

# Step 4: Compute cumulative distribution function (CDF)
cdf = np.cumsum(pr)

# Step 5: Apply formula sk = (L-1)*cdf
sk = np.round((L-1) * cdf).astype(np.uint8)

# Step 6: Map original intensities to new equalized values
equalized = sk[img]

# Step 7: Plot results
plt.figure(figsize=(12,6))

# Original Image
plt.subplot(2,2,1)
plt.imshow(img, cmap='gray')
plt.title("Original Image")
plt.axis("off")

# Histogram of Original
plt.subplot(2,2,2)
plt.hist(img.ravel(), bins=256, range=[0,256], color='blue')
plt.title("Histogram (Original)")

# Equalized Image
plt.subplot(2,2,3)
plt.imshow(equalized, cmap='gray')
plt.title("Equalized Image")
plt.axis("off")

# Histogram of Equalized
plt.subplot(2,2,4)
plt.hist(equalized.ravel(), bins=256, range=[0,256], color='green')
plt.title("Histogram (Equalized)")

plt.tight_layout()
plt.show()
#2. Transformation - Gray level modification

import cv2
import numpy as np
import matplotlib.pyplot as plt

img = cv2.imread("beach.jpeg", cv2.IMREAD_GRAYSCALE)

# Negative transformation
negative_img = 255 - img

# Logarithmic transformation
c = 255 / np.log(1 + np.max(img))
log_img = c * (np.log(1 + img.astype(np.float32)))
log_img = np.uint8(log_img)

# Power-law (gamma) transformation
gamma = 0.5   # < 1 brightens, > 1 darkens
gamma_img = np.array(255 * (img / 255) ** gamma, dtype='uint8')

# Contrast stretching (linear normalization)
min_val, max_val = np.min(img), np.max(img)
contrast_stretch = (img - min_val) * (255 / (max_val - min_val))
contrast_stretch = np.uint8(contrast_stretch)

plt.figure(figsize=(15,8))

plt.subplot(2,3,1)
plt.title("Original")
plt.imshow(img, cmap="gray")
plt.axis("off")

plt.subplot(2,3,2)
plt.title("Negative")
plt.imshow(negative_img, cmap="gray")
plt.axis("off")

plt.subplot(2,3,3)
plt.title("Log Transformation")
plt.imshow(log_img, cmap="gray")
plt.axis("off")

plt.subplot(2,3,4)
plt.title(f"Gamma (γ={gamma})")
plt.imshow(gamma_img, cmap="gray")
plt.axis("off")

plt.subplot(2,3,5)
plt.title("Contrast Stretching")
plt.imshow(contrast_stretch, cmap="gray")
plt.axis("off")

plt.show()

#3. Edge detection - Canny and other masks

import numpy as np
import cv2

original_image = np.array([[10, 10, 10, 10, 10],
                 [10, 10, 50, 10, 10],
                 [10, 50, 255, 50, 10],
                 [10, 10, 50, 10, 10],
                 [10, 10, 10, 10, 10]])

image_copy = original_image.copy()

img_array = np.array(original_image, dtype=np.float64)
original_image  = cv2.GaussianBlur(img_array, (3, 3), 1)
print(original_image)

prewitt_x = np.array([[-1, 0, 1],
             [-1, 0, 1],
             [-1, 0, 1]])

prewitt_y = np.array([[1, 1, 1],
           [0, 0, 0],
           [-1, -1, -1]])

img_h, img_w = original_image.shape
kernel_h, kernel_w = prewitt_x.shape

padded_image = np.zeros((img_h + 2, img_w + 2))
padded_image[1:-1, 1:-1] = original_image

G_x = np.zeros_like(original_image)

for i in range(1, img_h - 1):
    for j in range(1, img_w - 1):
        region = padded_image[i:i+kernel_h, j:j+kernel_w]
        G_x[i, j] = np.round(np.sum(region * prewitt_x))

print("\nGx:")
print(G_x)

padded_image = np.zeros((img_h + 2, img_w + 2))
padded_image[1:-1, 1:-1] = original_image

G_y = np.zeros_like(original_image)

for i in range(1, img_h - 1):
    for j in range(1, img_w - 1):
        region = padded_image[i:i+kernel_h, j:j+kernel_w]
        G_y[i, j] = np.round(np.sum(region * prewitt_y))

print("\nGy:")
print(G_y)

magnitude_matrix = np.sqrt(G_x**2 + G_y**2)

magnitude_matrix[0, :] = 0
magnitude_matrix[-1, :] = 0
magnitude_matrix[:, 0] = 0
magnitude_matrix[:, -1] = 0

print("\nMagnitude Image:")
print(magnitude_matrix)

orientation_matrix = np.arctan2(G_y, G_x) * 180 / np.pi
orientation_matrix = np.round(np.mod(orientation_matrix, 180))
print("\nOrientation Matrix:")
print(orientation_matrix)

new_orientation_matrix = []
for i in orientation_matrix:
    new_row = []
    for j in i:
        if j >= 0 and j < 22.5:
            new_row.append(0)
        elif j >= 22.5 and j < 67.5:
            new_row.append(45)
        elif j >=67.5 and j < 112.5:
            new_row.append(90)
        elif j >= 112.5 and j < 157.5:
            new_row.append(135)
        elif j >= 157.5 and j <= 180:
            new_row.append(180)
    new_orientation_matrix.append(new_row)

suppressed_magnitude = np.array([[0 for _ in range(len(row))] for row in magnitude_matrix])

rows = len(magnitude_matrix)
cols = len(magnitude_matrix[0])

for i in range(rows):
    for j in range(cols):
        current_magnitude = magnitude_matrix[i][j]
        orientation = new_orientation_matrix[i][j]

        neighbor1_magnitude = -1
        neighbor2_magnitude = -1

        if orientation == 0 or orientation == 180:
            if j > 0:
                neighbor1_magnitude = magnitude_matrix[i][j-1]
            if j < cols - 1:
                neighbor2_magnitude = magnitude_matrix[i][j+1]

        elif orientation == 45:
            if i > 0 and j < cols - 1:
                neighbor1_magnitude = magnitude_matrix[i-1][j+1]
            if i < rows - 1 and j > 0:
                neighbor2_magnitude = magnitude_matrix[i+1][j-1]

        elif orientation == 90:
            if i > 0:
                neighbor1_magnitude = magnitude_matrix[i-1][j]
            if i < rows - 1:
                neighbor2_magnitude = magnitude_matrix[i+1][j]

        elif orientation == 135:
            if i > 0 and j > 0:
                neighbor1_magnitude = magnitude_matrix[i-1][j-1]
            if i < rows - 1 and j < cols - 1:
                neighbor2_magnitude = magnitude_matrix[i+1][j+1]

        if current_magnitude >= neighbor1_magnitude and current_magnitude >= neighbor2_magnitude:
            suppressed_magnitude[i][j] = current_magnitude
        else:
            suppressed_magnitude[i][j] = 0

print("\nSuppressed Magnitude Matrix:")
for row in suppressed_magnitude:
    print(row)

#4. Binary Image Analysis - Connected components and labelling

import numpy as np

img = np.array([[0, 0, 1, 0, 0, 1],
       [1, 1, 1, 0, 1, 1],
       [0, 1, 0, 0, 0, 0],
       [0, 0, 0, 1, 1, 1],
       [0, 0, 0, 1, 0, 1],
       [1, 1, 0, 0, 0, 0]])

result = np.zeros_like(img)

if img[0][0] == 0:
    label = 0
else:
    label = 1

for i in range(1, len(img[0])):
    if img[0][i] == 1:
        if result[0][i - 1] != 0:
            result[0][i] = result[0][i - 1]
        else:
            label += 1
            result[0][i] = label

d = {}

for i in range(1, len(img)):
    if img[i][0] == 1:
        if result[i - 1][0] != 0:
            result[i][0] = result[i - 1][0]
        else:
            label += 1
            result[i][0] = label
    for j in range(1, len(img[0])):
        if img[i][j] == 1:
            if result[i][j - 1] != 0 and result[i - 1][j] != 0:
                min_val = min(result[i][j - 1], result[i - 1][j])
                result[i][j] = min_val
                d[max(result[i][j - 1], result[i - 1][j])] = min_val
            elif result[i][j - 1] == 0 and result[i - 1][j] == 0:
                label += 1
                result[i][j] = label
            else:
                result[i][j] = max(result[i][j - 1], result[i - 1][j])

print("First Parse")
print(result)

for i in range(len(img)):
    for j in range(len(img[0])):
        if result[i][j] in d:
            result[i][j] = d[result[i][j]]

print("Second Parse")
print(result)

#5. Arithmetic Logical operations

import cv2
import numpy as np
import matplotlib.pyplot as plt

def multiply_images(img1, img2):

    img1_norm = img1.astype(np.float32) / 255.0
    img2_norm = img2.astype(np.float32) / 255.0

    result_norm = img1_norm * img2_norm

    result = (result_norm * 255.0).astype(img1.dtype)

    return result

def divide_images(img1, img2):

    img1_norm = img1.astype(np.float32) / 255.0
    img2_norm = img2 / 255.0

    result_norm = img1_norm / img2_norm

    result_norm = np.clip(result_norm, 0.0, 1.0)

    result = (result_norm * 255.0).astype(img1.dtype)

    return result


img1 = cv2.imread("beach.jpeg", cv2.IMREAD_GRAYSCALE)
img2 = cv2.imread("bird.jpeg", cv2.IMREAD_GRAYSCALE)

if img1 is not None and img2 is not None:
    if img1.shape != img2.shape:
        print("Resizing img2 to match img1 shape.")
        img2 = cv2.resize(img2, (img1.shape[1], img1.shape[0]))

    multiplied_img = multiply_images(img1, img2)

    divided_img = divide_images(img1, img2)

    if multiplied_img is not None and divided_img is not None:
        fig, axs = plt.subplots(1, 4, figsize=(20, 5))

        axs[0].imshow(img1, cmap='gray')
        axs[0].set_title("Image 1")
        axs[0].axis('off')

        axs[1].imshow(img2, cmap='gray')
        axs[1].set_title("Image 2")
        axs[1].axis('off')

        axs[2].imshow(multiplied_img, cmap='gray')
        axs[2].set_title("Multiplied Image")
        axs[2].axis('off')

        axs[3].imshow(divided_img, cmap='gray')
        axs[3].set_title("Divided Image")
        axs[3].axis('off')

        plt.tight_layout()
        plt.show()

# AND & OR
import cv2
import numpy as np
from matplotlib import pyplot as plt


image = cv2.imread('beach.jpeg', cv2.IMREAD_GRAYSCALE)


height, width = image.shape[:2]


display(plt.imshow(image, cmap='gray', vmin=0, vmax=255))
plt.axis('off')
plt.show()


# mask value
mask_value =0b10000000


for i in range(image.shape[0]):
   for j in range(image.shape[1]):
       image[i,j] = image[i,j] & mask_value


display(plt.imshow(image, cmap='gray', vmin=0, vmax=255))
plt.axis('off')
plt.show()


image = cv2.imread('beach.jpeg', cv2.IMREAD_GRAYSCALE)


height, width = image.shape[:2]


display(plt.imshow(image, cmap='gray', vmin=0, vmax=255))
plt.axis('off')
plt.show()


for i in range(image.shape[0]):
   for j in range(image.shape[1]):
       image[i,j] = image[i,j] | mask_value


display(plt.imshow(image, cmap='gray', vmin=0, vmax=255))
plt.axis('off')
plt.show()

#6. Sampling and Quantization

import cv2
import numpy as np
import matplotlib.pyplot as plt

img = cv2.imread("beach.jpeg", cv2.IMREAD_GRAYSCALE)

h, w = img.shape
print(f"Original size: {h}x{w}, Intensity range: {img.min()} to {img.max()}")

sampling_factor = 2   # keep every 2nd pixel
sampled_img = img[::sampling_factor, ::sampling_factor]

def quantize(img, levels):
    L = 256  # original gray levels
    step = L // levels
    quantized = (img // step) * step
    return quantized

quantized_img = quantize(img, levels=16)   # reduce to 16 gray levels

plt.figure(figsize=(12,6))

plt.subplot(1,3,1)
plt.title("Original Image")
plt.imshow(img, cmap="gray")
plt.axis("off")

plt.subplot(1,3,2)
plt.title("Sampled Image")
plt.imshow(sampled_img, cmap="gray")
plt.axis("off")

plt.subplot(1,3,3)
plt.title("Quantized Image (16 levels)")
plt.imshow(quantized_img, cmap="gray")
plt.axis("off")

plt.show()

#7. Thresholding - binary, otsu's thresholding, multiple thresholding

import cv2
import numpy as np
import matplotlib.pyplot as plt

img = cv2.imread("beach.jpeg", cv2.IMREAD_GRAYSCALE)

hist, bins = np.histogram(img.ravel(), 256, [0,256])
total_pixels = img.shape[0] * img.shape[1]

current_max, threshold = 0, 0
sum_total, sum_foreground, weight_background = 0, 0, 0

for i in range(256):
    sum_total += i * hist[i]

for t in range(256):
    weight_background += hist[t]
    if weight_background == 0:
        continue
    weight_foreground = total_pixels - weight_background
    if weight_foreground == 0:
        break

    sum_foreground += t * hist[t]

    mean_background = sum_foreground / weight_background
    mean_foreground = (sum_total - sum_foreground) / weight_foreground

    var_between = weight_background * weight_foreground * (mean_background - mean_foreground) ** 2

    if var_between > current_max:
        current_max = var_between
        threshold = t

print(f"Optimal threshold using Otsu's method = {threshold}")

_, otsu_img = cv2.threshold(img, threshold, 255, cv2.THRESH_BINARY)

plt.figure(figsize=(12,6))

plt.subplot(1,3,1)
plt.title("Original")
plt.imshow(img, cmap="gray")
plt.axis("off")

plt.subplot(1,3,2)
plt.title("Histogram")
plt.plot(hist)
plt.axvline(threshold, color='r', linestyle='--', label=f"T={threshold}")
plt.legend()

plt.subplot(1,3,3)
plt.title("Otsu Thresholded")
plt.imshow(otsu_img, cmap="gray")
plt.axis("off")

plt.show()

#8. First order hold - zero order hold

import cv2
import numpy as np
import matplotlib as plt

# b.i Zero order hold (nearest neighbor by duplication)
def zoom_zero_order(image, factor):
    h, w, c = image.shape
    zoomed = np.zeros((h * factor, w * factor, c), dtype=image.dtype)
    for i in range(h):
        for j in range(w):
            zoomed[i*factor:(i+1)*factor, j*factor:(j+1)*factor] = image[i, j]
    return zoomed

# b.ii First order hold (simple linear interpolation)
def zoom_first_order(image, factor):
    h, w, c = image.shape
    zoomed = np.zeros((h * factor, w * factor, c), dtype=np.uint8)
    for i in range(h * factor):
        for j in range(w * factor):
            x = i / factor
            y = j / factor
            x0 = int(np.floor(x))
            x1 = min(x0 + 1, h - 1)
            y0 = int(np.floor(y))
            y1 = min(y0 + 1, w - 1)

            a = x - x0
            b = y - y0

            zoomed[i, j] = (
                (1 - a) * (1 - b) * image[x0, y0] +
                (a) * (1 - b) * image[x1, y0] +
                (1 - a) * (b) * image[x0, y1] +
                (a) * (b) * image[x1, y1]
            )
    return zoomed

image = cv2.imread("beach.jpeg")  # replace with your image path
zoomed_zero = zoom_zero_order(image, 2)
zoomed_first = zoom_first_order(image, 2)

cv2.imwrite("zoomed_zero.jpg", zoomed_zero)
cv2.imwrite("zoomed_first.jpg", zoomed_first)


#region growing splitiing
import numpy as np

def homogeneity_test(arr, threshold):
    """Check if region is homogeneous based on threshold"""
    min_val = np.min(arr)
    max_val = np.max(arr)
    if max_val - min_val <= threshold:
        return True
    return False

def split_and_merge(img, threshold):
    """Recursive split and merge segmentation"""
    size = img.shape[0]

    # Base case: if homogeneous or 1x1 block → merge
    if homogeneity_test(img, threshold) or size == 1:
        mean_val = np.mean(img, dtype=int)
        return np.full_like(img, mean_val)

    # Ensure even split
    mid = size // 2

    # Pad odd-sized regions so splitting works
    if size % 2 != 0:
        img = np.pad(img, ((0, 1), (0, 1)), mode='edge')
        size = img.shape[0]
        mid = size // 2

    # Split into quadrants
    top_left = split_and_merge(img[0:mid, 0:mid], threshold)
    top_right = split_and_merge(img[0:mid, mid:size], threshold)
    bottom_left = split_and_merge(img[mid:size, 0:mid], threshold)
    bottom_right = split_and_merge(img[mid:size, mid:size], threshold)

    # Merge quadrants
    top = np.hstack((top_left, top_right))
    bottom = np.hstack((bottom_left, bottom_right))
    merged = np.vstack((top, bottom))

    # Crop back if padding was added
    return merged[:img.shape[0], :img.shape[1]]

# ============================
# Example Test Images
# ============================
image1 = np.array([[10, 9, 9, 4, 0],
                  [0, 6, 6, 2, 2],
                  [5, 9, 8, 4, 3],
                  [7, 5, 5, 4, 3],
                  [8, 10, 8, 5, 0]])

image2 = np.array([[6, 5, 6, 6, 7, 7, 6, 6],
                  [6, 7, 6, 7, 5, 5, 4, 7],
                  [6, 6, 4, 4, 3, 2, 5, 6],
                  [5, 4, 5, 4, 2, 3, 4, 6],
                  [0, 3, 2, 3, 3, 2, 4, 7],
                  [0, 0, 0, 0, 2, 2, 5, 6],
                  [1, 1, 0, 1, 0, 3, 4, 4],
                  [1, 0, 1, 0, 2, 3, 5, 4]])

# ============================
# Run Split and Merge
# ============================
threshold = 3
print("Original Image:\n", image2)

result = split_and_merge(image2, threshold)
print("\nSegmented Image (Split & Merge):\n", result)
